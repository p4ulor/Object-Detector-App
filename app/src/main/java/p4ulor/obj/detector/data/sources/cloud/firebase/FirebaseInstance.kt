package p4ulor.obj.detector.data.sources.cloud.firebase

import android.content.Context
import androidx.credentials.ClearCredentialStateRequest
import androidx.credentials.Credential
import androidx.credentials.CredentialManager
import androidx.credentials.CustomCredential
import androidx.credentials.GetCredentialRequest
import com.google.android.libraries.identity.googleid.GetGoogleIdOption
import com.google.android.libraries.identity.googleid.GoogleIdTokenCredential
import com.google.firebase.Firebase
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.FirebaseUser
import com.google.firebase.auth.GoogleAuthProvider
import com.google.firebase.firestore.Query
import com.google.firebase.firestore.firestore
import com.google.firebase.firestore.toObject
import kotlinx.coroutines.CompletableDeferred
import kotlinx.coroutines.tasks.await
import org.koin.core.annotation.Single
import p4ulor.obj.detector.R
import p4ulor.obj.detector.d
import p4ulor.obj.detector.data.domains.firebase.TopUser
import p4ulor.obj.detector.data.domains.firebase.User
import p4ulor.obj.detector.data.domains.firebase.UserAchievement
import p4ulor.obj.detector.data.domains.mediapipe.Achievement
import p4ulor.obj.detector.data.domains.mediapipe.calculatePoints
import p4ulor.obj.detector.data.utils.executorCommon
import p4ulor.obj.detector.e
import p4ulor.obj.detector.i

/**
 * Provides methods to create and update documents from the Firebase project
 * - https://firebase.google.com/docs/auth/android/google-signin
 */
@Single
class FirebaseInstance {
    // Firestore
    private val db = Firebase.firestore
    private val usersCollection = db.collection(FbCollection.Users.id)
    private val topUsersCollection = db.collection(FbCollection.TopUsers.id)

    // Auth
    private val fbAuth = FirebaseAuth.getInstance()
    private var crendentialRequest: GetCredentialRequest? = null
    private var credentialManager: CredentialManager? = null
    private val currUserId: String
        get() = fbAuth.currentUser?.uid.orEmpty()

    fun init(ctx: Context) {
        i("Obtained user ${fbAuth.currentUser}")
        val googleIdOption = GetGoogleIdOption.Builder()
            .setServerClientId(ctx.getString(R.string.default_web_client_id)) // string is build-generated by google-services Gradle plugin
            .setFilterByAuthorizedAccounts(false) // show all available accounts, not just the ones used before
            .build()

        crendentialRequest = GetCredentialRequest(credentialOptions = listOf(googleIdOption))
        credentialManager = CredentialManager.create(ctx)
    }

    suspend fun signInWithGoogle(ctx: Context): User? {
        runCatching {
            val selectedCredential = credentialManager?.getCredential( // launch Credential Manager (native) UI
                context = ctx,
                request = crendentialRequest ?: error("crendentialRequest is null")
            )?.credential ?: error("selectedCredential is null")

            if (selectedCredential.isGoogleSignIn) {
                val googleIdTokenCredential = GoogleIdTokenCredential.createFrom(selectedCredential.data) // create Google ID Token
                return firebaseAuthWithGoogle(googleIdTokenCredential.idToken)?.let { fbUser ->
                    createOrGetUser(fbUser)
                }
            } else {
                e("signInWithGoogle: credential is not of type Google ID")
            }
        }.onFailure { // Mostly to catch when the user closes the dialog
            e("signInWithGoogle failure: $it")
        }
        return null
    }

    /** Clear the current user credential state from all credential providers */
    suspend fun signOut() {
        runCatching {
            fbAuth.signOut()
            val clearRequest = ClearCredentialStateRequest()
            credentialManager?.clearCredentialState(clearRequest)
        }.onFailure {
            e("signOut failure: $it")
        }
    }

    suspend fun getTopUsers(): Result<List<User>> {
        var result = Result.success<List<User>>(emptyList())
        topUsersCollection
            .orderBy(TopUser.POINTS, Query.Direction.DESCENDING)
            .limit(FbCollection.TopUsers.maxCollectionSize.toLong())
            .get()
            .addOnSuccessListener { query ->
                result = Result.success(
                    buildList {
                        query.documents.filterNotNull().forEach {
                            val user = it.toObject<User>()
                            if (user != null) {
                                add(user)
                            } else {
                                e("Unexpected error, user is null")
                            }
                        }
                    }
                )
            }
            .addOnFailureListener {
                result = Result.failure(it)
            }
            .await()

        return result
    }

    suspend fun updateUserAchievements(achievements: List<UserAchievement>, points: Float): Result<Unit> {
        val error = StringBuilder("")
        usersCollection.document(currUserId)
            .update(User.ACHIEVEMENTS, achievements)
            .addOnSuccessListener { i("Achievements set") }
            .addOnFailureListener { error.append(it.message) }
            .await()

        usersCollection.document(currUserId)
            .update(User.POINTS, points)
            .addOnSuccessListener { i("Points set") }
            .addOnFailureListener { error.append(it.message) }
            .await()

        return if (error.isEmpty()) {
            Result.success(Unit)
        } else {
            Result.failure(error(error.toString()))
        }
    }

    fun deleteAccount() {
        usersCollection.document(currUserId)
            .delete()
            .addOnSuccessListener { i("User data deleted") }
            .addOnFailureListener { e("Error deleting user data") }
        fbAuth.currentUser?.let {
            it.delete()
            .addOnSuccessListener { i("User deleted") }
            .addOnFailureListener { e("Error deleting user") }
        }
    }

    private suspend fun createOrGetUser(fbUser: FirebaseUser) : User? {
        val result = CompletableDeferred<User?>() // because I don't want to use callbacks
        val uid = fbUser?.uid.orEmpty() // (will just fail if its null)
        usersCollection.document(uid).get()
            .addOnSuccessListener { doc ->
                if (!doc.exists()) {
                    val newUser = User.createFrom(fbUser)

                    usersCollection.document(uid)
                        .set(newUser)
                        .addOnSuccessListener {
                            i("User document created")
                            result.complete(newUser)
                        }
                        .addOnFailureListener { e ->
                            e("Error creating user document: ${e.message}")
                            result.complete(null)
                        }
                } else {
                    d("User document already exists for uid: $uid")
                    result.complete(doc.toObject<User>())
                }
            }
            .addOnFailureListener { e ->
                e("Error checking for existing user document for uid: $uid - ${e.message}")
                result.complete(null)
            }
        return result.await()
    }

    /**
     * Sign in to Firebase using Google ID Token
     * https://firebase.google.com/docs/reference/kotlin/com/google/firebase/auth/GoogleAuthProvider
     */
    private suspend fun firebaseAuthWithGoogle(idToken: String) : FirebaseUser? {
        val credential = GoogleAuthProvider.getCredential(idToken, /* accessToken = */ null)
        val result = CompletableDeferred<Boolean>() // because I don't want to use callbacks
        var currUser: FirebaseUser? = null
        fbAuth.signInWithCredential(credential)
            .addOnCompleteListener(executorCommon) { task ->
                if (task.isSuccessful) {
                    d("firebaseAuthWithGoogle: currUser = ${currUser?.displayName}")
                    currUser = fbAuth.currentUser
                    result.complete(true)
                } else {
                    e("firebaseAuthWithGoogle: ${task.exception?.message}")
                    result.complete(true)
                }
            }
        result.await()
        return currUser
    }
}

private val Credential.isGoogleSignIn: Boolean
    get() = this is CustomCredential && type == GoogleIdTokenCredential.TYPE_GOOGLE_ID_TOKEN_CREDENTIAL
