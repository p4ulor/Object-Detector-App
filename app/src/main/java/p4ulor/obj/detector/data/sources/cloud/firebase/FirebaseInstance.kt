package p4ulor.obj.detector.data.sources.cloud.firebase

import android.content.Context
import androidx.credentials.ClearCredentialStateRequest
import androidx.credentials.Credential
import androidx.credentials.CredentialManager
import androidx.credentials.CustomCredential
import androidx.credentials.GetCredentialRequest
import com.google.android.libraries.identity.googleid.GetGoogleIdOption
import com.google.android.libraries.identity.googleid.GoogleIdTokenCredential
import com.google.firebase.Firebase
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.FirebaseUser
import com.google.firebase.auth.GoogleAuthProvider
import com.google.firebase.firestore.Query
import com.google.firebase.firestore.firestore
import com.google.firebase.firestore.toObject
import kotlinx.coroutines.CompletableDeferred
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.tasks.await
import org.koin.core.annotation.Single
import p4ulor.obj.detector.R
import p4ulor.obj.detector.d
import p4ulor.obj.detector.data.domains.firebase.ObjectDetectionStats
import p4ulor.obj.detector.data.domains.firebase.TopUser
import p4ulor.obj.detector.data.domains.firebase.User
import p4ulor.obj.detector.data.domains.firebase.UserAchievement
import p4ulor.obj.detector.data.utils.executorCommon
import p4ulor.obj.detector.e
import p4ulor.obj.detector.i

/**
 * Provides methods to create and update documents from the Firebase project
 * - https://firebase.google.com/docs/auth/android/google-signin
 */
@Single
class FirebaseInstance : CoroutineScope by CoroutineScope(Dispatchers.IO) {
    // Firestore
    private val db = Firebase.firestore
    private val usersCollection = db.collection(FbCollection.Users.id)
    private val topUsersCollection = db.collection(FbCollection.TopUsers.id)
    private val topObjectsCollection = db.collection(FbCollection.TopObjects.id)

    // Auth
    private val fbAuth = FirebaseAuth.getInstance()
    private var crendentialRequest: GetCredentialRequest? = null
    private var credentialManager: CredentialManager? = null
    private val currUserId: String
        get() = fbAuth.currentUser?.uid.orEmpty()

    fun init(ctx: Context) {
        i("Obtained user ${fbAuth.currentUser}")
        val googleIdOption = GetGoogleIdOption.Builder()
            .setServerClientId(ctx.getString(R.string.default_web_client_id)) // string is build-generated by google-services Gradle plugin
            .setFilterByAuthorizedAccounts(false) // show all available accounts, not just the ones used before
            .build()

        crendentialRequest = GetCredentialRequest(credentialOptions = listOf(googleIdOption))
        credentialManager = CredentialManager.create(ctx)
    }

    suspend fun signInWithGoogle(ctx: Context): User? {
        return runCatching {
            val selectedCredential = credentialManager?.getCredential( // launch Credential Manager (native) UI
                context = ctx,
                request = crendentialRequest ?: error("crendentialRequest is null")
            )?.credential ?: error("selectedCredential is null")

            if (selectedCredential.isGoogleSignIn) {
                val googleIdTokenCredential = GoogleIdTokenCredential.createFrom(selectedCredential.data) // create Google ID Token
                firebaseAuthWithGoogle(googleIdTokenCredential.idToken)?.let { fbUser ->
                    createOrGetUser(fbUser)
                }
            } else {
                e("signInWithGoogle: credential is not of type Google ID")
                null
            }
        }.onFailure { // Mostly to catch when the user closes the dialog, but can also fail if the app signing doesn't match to the signings that were added to the firebase project when creating the google-services.json). Per example when installing a new Android Studio, a different debug keystore will be at ~/.android/debug.keystore . You can replace your curr file with that other .keystore (thus avoiding creating a new google-services.json. Then, clean gradle build, invalidate caches and restart. (long story short: windows 11 messed up my wifi in my Ubuntu 22, so I had to get Ubuntu 24. yeah...)
            e("signInWithGoogle failure: $it")
        }.getOrNull()
    }

    /** Clear the current user credential state from all credential providers */
    suspend fun signOut() {
        runCatching {
            fbAuth.signOut()
            val clearRequest = ClearCredentialStateRequest()
            credentialManager?.clearCredentialState(clearRequest)
        }.onFailure {
            e("signOut failure: $it")
        }
    }

    suspend fun getTopUsers(): Result<List<User>> = coroutineScope {
        val result = CompletableDeferred<Result<List<User>>>()
        topUsersCollection
            .orderBy(TopUser.POINTS, Query.Direction.DESCENDING)
            .limit(FbCollection.TopUsers.desiredDocsCap.toLong())
            .get()
            .addOnSuccessListener { query ->
                i("getTopUsers addOnSuccessListener")
                launch {
                    val usersWithTopPoints = query.documents.filterNotNull()
                        .map { it.id }
                    val topUsers = getUsers(usersWithTopPoints)
                    result.complete(Result.success(topUsers))
                }
            }
            .addOnFailureListener {
                result.complete(Result.failure(it))
            }
            // .await() // wont do the job because we launch a coroutine in addOnSuccessListener
        return@coroutineScope result.await()
    }

    suspend fun getTopObjects(): Result<List<ObjectDetectionStats>> {
        val result = CompletableDeferred<Result<List<ObjectDetectionStats>>>()
        topObjectsCollection
            .orderBy(ObjectDetectionStats.DETECTION_COUNT, Query.Direction.DESCENDING)
            .limit(FbCollection.TopObjects.desiredDocsCap.toLong())
            .get()
            .addOnSuccessListener { query ->
                i("getTopObjects addOnSuccessListener")
                val topObjects = query.documents.filterNotNull().map {
                    ObjectDetectionStats.from(it)
                }
                result.complete(Result.success(topObjects))
            }
            .addOnFailureListener {
                result.complete(Result.failure(it))
            }
        return result.await()
    }

    private suspend fun getUsers(ids: List<String>) : List<User> = coroutineScope {
        return@coroutineScope ids.map { id ->
            coroutineScope {
                async {
                    runCatching {
                        usersCollection.document(id)
                            .get()
                            .await()
                            .toObject<User>()!!
                    }
                    .onFailure {
                        e("Error getting user $id")
                    }.getOrNull()
                }
            }
        }.awaitAll().filterNotNull()
    }

    suspend fun updateUserAchievements(achievements: List<UserAchievement>, points: Float): Result<Unit> {
        val error = StringBuilder("")
        usersCollection.document(currUserId)
            .update(User.ACHIEVEMENTS, achievements)
            .addOnSuccessListener { i("Achievements set") }
            .addOnFailureListener { error.append(it.message) }
            .await()

        usersCollection.document(currUserId)
            .update(User.POINTS, points)
            .addOnSuccessListener { i("Points set") }
            .addOnFailureListener { error.append(it.message) }
            .await()

        return if (error.isEmpty()) {
            Result.success(Unit)
        } else {
            Result.failure(Throwable(error.toString()))
        }
    }

    fun deleteAccount() {
        usersCollection.document(currUserId)
            .delete()
            .addOnSuccessListener {
                i("User $currUserId deleted")
                fbAuth.currentUser?.let {
                    it.delete()
                        .addOnSuccessListener { i("User deleted") }
                        .addOnFailureListener { e("Error deleting user") }
                }
            }
            .addOnFailureListener { e("Error deleting user $currUserId") }
    }

    private suspend fun createOrGetUser(fbUser: FirebaseUser) : User? {
        val result = CompletableDeferred<User?>() // because I don't want to use callbacks
        val uid = fbUser.uid
        usersCollection.document(uid).get()
            .addOnSuccessListener { doc ->
                if (!doc.exists()) {
                    val newUser = User.createFrom(fbUser)

                    usersCollection.document(uid)
                        .set(newUser)
                        .addOnSuccessListener {
                            i("User document created")
                            result.complete(newUser)
                        }
                        .addOnFailureListener { e ->
                            e("Error creating user document: ${e.message}")
                            result.complete(null)
                        }
                } else {
                    d("User document already exists for uid: $uid")
                    result.complete(doc.toObject<User>())
                }
            }
            .addOnFailureListener { e ->
                e("Error checking for existing user document for uid: $uid - ${e.message}")
                result.complete(null)
            }
        return result.await()
    }

    /**
     * Sign in to Firebase using Google ID Token
     * https://firebase.google.com/docs/reference/kotlin/com/google/firebase/auth/GoogleAuthProvider
     */
    private suspend fun firebaseAuthWithGoogle(idToken: String) : FirebaseUser? {
        val credential = GoogleAuthProvider.getCredential(idToken, /* accessToken = */ null)
        val result = CompletableDeferred<Boolean>() // because I don't want to use callbacks
        var currUser: FirebaseUser? = null
        fbAuth.signInWithCredential(credential)
            .addOnCompleteListener(executorCommon) { task ->
                if (task.isSuccessful) {
                    d("firebaseAuthWithGoogle: currUser = ${currUser?.displayName}")
                    currUser = fbAuth.currentUser
                    result.complete(true)
                } else {
                    e("firebaseAuthWithGoogle: ${task.exception?.message}")
                    result.complete(true)
                }
            }
        result.await()
        return currUser
    }
}

private val Credential.isGoogleSignIn: Boolean
    get() = this is CustomCredential && type == GoogleIdTokenCredential.TYPE_GOOGLE_ID_TOKEN_CREDENTIAL
