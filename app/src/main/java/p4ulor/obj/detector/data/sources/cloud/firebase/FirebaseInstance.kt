package p4ulor.obj.detector.data.sources.cloud.firebase

import android.content.Context
import androidx.credentials.ClearCredentialStateRequest
import androidx.credentials.Credential
import androidx.credentials.CredentialManager
import androidx.credentials.CustomCredential
import androidx.credentials.GetCredentialRequest
import com.google.android.libraries.identity.googleid.GetGoogleIdOption
import com.google.android.libraries.identity.googleid.GoogleIdTokenCredential
import com.google.firebase.Firebase
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.FirebaseUser
import com.google.firebase.auth.GoogleAuthProvider
import com.google.firebase.firestore.firestore
import com.google.firebase.firestore.toObject
import kotlinx.coroutines.CompletableDeferred
import org.koin.core.annotation.Single
import p4ulor.obj.detector.R
import p4ulor.obj.detector.d
import p4ulor.obj.detector.data.domains.firebase.User
import p4ulor.obj.detector.data.utils.executorCommon
import p4ulor.obj.detector.e
import p4ulor.obj.detector.i

/**
 * The main
 * - https://firebase.google.com/docs/auth/android/google-signin
 */
@Single
class FirebaseInstance {
    // Firestore
    private val db = Firebase.firestore
    private val usersCollection = db.collection(FbCollection.Users.id)

    // Auth
    private val fbAuth = FirebaseAuth.getInstance()
    private var currUser: FirebaseUser? = null
    private var crendentialRequest: GetCredentialRequest? = null
    private var credentialManager: CredentialManager? = null

    fun init(ctx: Context) {
        i("Obtained user ${fbAuth.currentUser}")
        currUser = fbAuth.currentUser
        currUser?.let {
            val name = it.displayName
            val email = it.email
            val photoUrl = it.photoUrl
            val uid = it.uid // unique to the Firebase project
        }

        val googleIdOption = GetGoogleIdOption.Builder()
            .setServerClientId(ctx.getString(R.string.default_web_client_id)) // string is build-generated by google-services Gradle plugin
            .setFilterByAuthorizedAccounts(false) // show all available accounts, not just the ones used before
            .build()

        crendentialRequest = GetCredentialRequest(credentialOptions = listOf(googleIdOption))
        credentialManager = CredentialManager.create(ctx)
    }

    suspend fun signInWithGoogle(ctx: Context): User? {
        runCatching {
            val selectedCredential = credentialManager?.getCredential( // launch Credential Manager (native) UI
                context = ctx,
                request = crendentialRequest ?: error("crendentialRequest is null")
            )?.credential ?: error("selectedCredential is null")

            if (selectedCredential.isGoogleSignIn) {
                val googleIdTokenCredential = GoogleIdTokenCredential.createFrom(selectedCredential.data) // create Google ID Token
                return firebaseAuthWithGoogle(googleIdTokenCredential.idToken)?.let { fbUser ->
                    createOrGetUser(fbUser)
                }
            } else {
                e("signInWithGoogle: credential is not of type Google ID")
            }
        }.onFailure { // Mostly to catch when the user closes the dialog
            e("signInWithGoogle failure: $it")
        }
        return null
    }

    /** Clear the current user credential state from all credential providers */
    suspend fun signOut() {
        runCatching {
            fbAuth.signOut()
            currUser = null
            val clearRequest = ClearCredentialStateRequest()
            credentialManager?.clearCredentialState(clearRequest)
        }.onFailure {
            e("signOut failure: $it")
        }
    }

    private suspend fun createOrGetUser(fbUser: FirebaseUser) : User? {
        val result = CompletableDeferred<User?>() // because I don't want to use callbacks
        val uid = fbUser?.uid.orEmpty() // (will just fail if its null)
        usersCollection.document(uid).get()
            .addOnSuccessListener { doc ->
                if (!doc.exists()) {
                    val newUser = User.createFrom(fbUser)

                    usersCollection.document(newUser.uuid)
                        .set(newUser)
                        .addOnSuccessListener {
                            i("User document created")
                            result.complete(newUser)
                        }
                        .addOnFailureListener { e ->
                            e("Error creating user document: ${e.message}")
                            result.complete(null)
                        }
                } else {
                    d("User document already exists for uid: $uid")
                    result.complete(doc.toObject<User>())
                }
            }
            .addOnFailureListener { e ->
                e("Error checking for existing user document for uid: $uid - ${e.message}")
                result.complete(null)
            }
        return result.await()
    }

    /**
     * Sign in to Firebase using Google ID Token
     * https://firebase.google.com/docs/reference/kotlin/com/google/firebase/auth/GoogleAuthProvider
     */
    private suspend fun firebaseAuthWithGoogle(idToken: String) : FirebaseUser? {
        val credential = GoogleAuthProvider.getCredential(idToken, /* accessToken = */ null)
        val result = CompletableDeferred<Boolean>() // because I don't want to use callbacks
        fbAuth.signInWithCredential(credential)
            .addOnCompleteListener(executorCommon) { task ->
                if (task.isSuccessful) {
                    d("firebaseAuthWithGoogle: currUser = ${currUser?.displayName}")
                    currUser = fbAuth.currentUser
                    result.complete(true)
                } else {
                    e("firebaseAuthWithGoogle: ${task.exception?.message}")
                    result.complete(true)
                }
            }
        result.await()
        return currUser
    }
}

private val Credential.isGoogleSignIn: Boolean
    get() = this is CustomCredential && type == GoogleIdTokenCredential.TYPE_GOOGLE_ID_TOKEN_CREDENTIAL
